// (c) mdsebook, wasowski, berger
// Run FSM interpreter with a textual frontend

package mdsebook.fsm.scala.external

import scala.collection.JavaConversions._

import mdsebook.fsm.FsmPackage
import mdsebook.fsm.FiniteStateMachine
import mdsebook.fsm.scala.Interpreter
import mdsebook.FsmStandaloneSetup
import mdsebook.scala.EMFScala._
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl

object Main extends App {

	// Change input file name of your state machine model here;
	// path is relative to project root
	val instanceFileName = "../mdsebook.fsm/test-files/CoffeeMachine.fsm"

  // Register our meta-model package for abstract syntax
  FsmPackage.eINSTANCE.eClass

  // Register a suitable resource factory for FSM files (generated by Xtext)
  // The "Fsm" prefix is the name of our language
  // it needs to change to refer to code generated for your language
  new FsmStandaloneSetup().createInjectorAndDoEMFRegistration

  // we are loading our file here
  val uri = URI.createURI (instanceFileName)
  var resource = new ResourceSetImpl().getResource (uri, true);

  // The call to get(0) below gives you the first model root.
  // If you open a directory instead of a file,
  // you can iterate over all models in it,
  // by changing 0 to a suitable index
  val m: FiniteStateMachine = resource.getContents.get (0).asInstanceOf[FiniteStateMachine]

  // We are reusing the interpreter from internalDSL.
  // It would be more elegant to refactor this,
  // moving the interpreter to the general fsm package
  // (as it is independent of the syntax technology)

  Interpreter.step (m.getInitial)
}

